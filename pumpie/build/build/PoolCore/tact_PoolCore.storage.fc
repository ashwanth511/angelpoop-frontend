;;
;; Type: StateInit
;; TLB: _ code:^cell data:^cell = StateInit
;;

((cell, cell)) $StateInit$_not_null(tuple v) inline {
    throw_if(128, null?(v));
    var (cell vvv'code, cell vvv'data) = __tact_tuple_destroy_2(v);
    return (vvv'code, vvv'data);
}

;;
;; Type: Context
;; TLB: _ bounced:bool sender:address value:int257 raw:^slice = Context
;;

_ $Context$_get_value((int, slice, int, slice) v) inline {
    var (v'bounced, v'sender, v'value, v'raw) = v;
    return v'value;
}

;;
;; Type: SendParameters
;; TLB: _ bounce:bool to:address value:int257 mode:int257 body:Maybe ^cell code:Maybe ^cell data:Maybe ^cell = SendParameters
;;

((int, slice, int, int, cell, cell, cell)) $SendParameters$_constructor_to_value_bounce_mode_body(slice $to, int $value, int $bounce, int $mode, cell $body) inline {
    return ($bounce, $to, $value, $mode, $body, null(), null());
}

((int, slice, int, int, cell, cell, cell)) $SendParameters$_constructor_to_value_bounce_mode(slice $to, int $value, int $bounce, int $mode) inline {
    return ($bounce, $to, $value, $mode, null(), null(), null());
}

((int, slice, int, int, cell, cell, cell)) $SendParameters$_constructor_bounce_to_value_mode_body_code_data(int $bounce, slice $to, int $value, int $mode, cell $body, cell $code, cell $data) inline {
    return ($bounce, $to, $value, $mode, $body, $code, $data);
}

((int, slice, int, int, cell, cell, cell)) $SendParameters$_constructor_to_value_body_mode(slice $to, int $value, cell $body, int $mode) inline {
    return (true, $to, $value, $mode, $body, null(), null());
}

((int, slice, int, int, cell, cell, cell)) $SendParameters$_constructor_to_value_mode(slice $to, int $value, int $mode) inline {
    return (true, $to, $value, $mode, null(), null(), null());
}

((int, slice, int, int, cell, cell, cell)) $SendParameters$_constructor_to_value_bounce_body_mode(slice $to, int $value, int $bounce, cell $body, int $mode) inline {
    return ($bounce, $to, $value, $mode, $body, null(), null());
}

((int, slice, int, int, cell, cell, cell)) $SendParameters$_constructor_to_value_bounce_mode_code_data(slice $to, int $value, int $bounce, int $mode, cell $code, cell $data) inline {
    return ($bounce, $to, $value, $mode, null(), $code, $data);
}

;;
;; Type: Deploy
;; Header: 0x946a98b6
;; TLB: deploy#946a98b6 queryId:uint64 = Deploy
;;

(slice, ((int))) $Deploy$_load(slice sc_0) inline {
    throw_unless(129, sc_0~load_uint(32) == 2490013878);
    var v'queryId = sc_0~load_uint(64);
    return (sc_0, (v'queryId));
}

;;
;; Type: DeployOk
;; Header: 0xaff90f57
;; TLB: deploy_ok#aff90f57 queryId:uint64 = DeployOk
;;

builder $DeployOk$_store(builder build_0, (int) v) inline {
    var (v'queryId) = v;
    build_0 = store_uint(build_0, 2952335191, 32);
    build_0 = build_0.store_uint(v'queryId, 64);
    return build_0;
}

cell $DeployOk$_store_cell((int) v) inline {
    return $DeployOk$_store(begin_cell(), v).end_cell();
}

((int)) $DeployOk$_constructor_queryId(int $queryId) inline {
    return ($queryId);
}

;;
;; Type: BuyTokens
;; Header: 0x30e5b29f
;; TLB: buy_tokens#30e5b29f resAddress:address tonAmount:int257 = BuyTokens
;;

builder $BuyTokens$_store(builder build_0, (slice, int) v) inline {
    var (v'resAddress, v'tonAmount) = v;
    build_0 = store_uint(build_0, 820359839, 32);
    build_0 = __tact_store_address(build_0, v'resAddress);
    build_0 = build_0.store_int(v'tonAmount, 257);
    return build_0;
}

cell $BuyTokens$_store_cell((slice, int) v) inline {
    return $BuyTokens$_store(begin_cell(), v).end_cell();
}

((slice, int)) $BuyTokens$_constructor_resAddress_tonAmount(slice $resAddress, int $tonAmount) inline {
    return ($resAddress, $tonAmount);
}

;;
;; Type: SellTokens
;; Header: 0x975489d8
;; TLB: sell_tokens#975489d8 resAddress:address tokenAmount:int257 = SellTokens
;;

builder $SellTokens$_store(builder build_0, (slice, int) v) inline {
    var (v'resAddress, v'tokenAmount) = v;
    build_0 = store_uint(build_0, 2538899928, 32);
    build_0 = __tact_store_address(build_0, v'resAddress);
    build_0 = build_0.store_int(v'tokenAmount, 257);
    return build_0;
}

cell $SellTokens$_store_cell((slice, int) v) inline {
    return $SellTokens$_store(begin_cell(), v).end_cell();
}

((slice, int)) $SellTokens$_constructor_resAddress_tokenAmount(slice $resAddress, int $tokenAmount) inline {
    return ($resAddress, $tokenAmount);
}

;;
;; Type: PoolBuy
;; Header: 0x323f9a04
;; TLB: pool_buy#323f9a04 jettonAddress:address = PoolBuy
;;

(slice, ((slice))) $PoolBuy$_load(slice sc_0) inline {
    throw_unless(129, sc_0~load_uint(32) == 843028996);
    var v'jettonAddress = sc_0~__tact_load_address();
    return (sc_0, (v'jettonAddress));
}

;;
;; Type: PoolSell
;; Header: 0x79a1872f
;; TLB: pool_sell#79a1872f jettonAddress:address to:address amount:coins = PoolSell
;;

(slice, ((slice, slice, int))) $PoolSell$_load(slice sc_0) inline {
    throw_unless(129, sc_0~load_uint(32) == 2040629039);
    var v'jettonAddress = sc_0~__tact_load_address();
    var v'to = sc_0~__tact_load_address();
    var v'amount = sc_0~load_coins();
    return (sc_0, (v'jettonAddress, v'to, v'amount));
}

;;
;; Type: AddJetton
;; Header: 0x6cbf9e55
;; TLB: add_jetton#6cbf9e55 jettonAddress:address = AddJetton
;;

(slice, ((slice))) $AddJetton$_load(slice sc_0) inline {
    throw_unless(129, sc_0~load_uint(32) == 1824497237);
    var v'jettonAddress = sc_0~__tact_load_address();
    return (sc_0, (v'jettonAddress));
}

;;
;; Type: BurnNotificationWithTon
;; Header: 0x0b85df36
;; TLB: burn_notification_with_ton#0b85df36 amount:coins tokenAmount:coins user:address = BurnNotificationWithTon
;;

(slice, ((int, int, slice))) $BurnNotificationWithTon$_load(slice sc_0) inline {
    throw_unless(129, sc_0~load_uint(32) == 193322806);
    var v'amount = sc_0~load_coins();
    var v'tokenAmount = sc_0~load_coins();
    var v'user = sc_0~__tact_load_address();
    return (sc_0, (v'amount, v'tokenAmount, v'user));
}

;;
;; Type: WithdrawFromPool
;; Header: 0xe33b0a47
;; TLB: withdraw_from_pool#e33b0a47 jettonAddress:address amount:coins = WithdrawFromPool
;;

(slice, ((slice, int))) $WithdrawFromPool$_load(slice sc_0) inline {
    throw_unless(129, sc_0~load_uint(32) == 3812297287);
    var v'jettonAddress = sc_0~__tact_load_address();
    var v'amount = sc_0~load_coins();
    return (sc_0, (v'jettonAddress, v'amount));
}

;;
;; Type: JettonPool
;; TLB: _ balance:coins isActive:bool = JettonPool
;;

builder $JettonPool$_store(builder build_0, (int, int) v) inline {
    var (v'balance, v'isActive) = v;
    build_0 = build_0.store_coins(v'balance);
    build_0 = build_0.store_int(v'isActive, 1);
    return build_0;
}

cell $JettonPool$_store_cell((int, int) v) inline {
    return $JettonPool$_store(begin_cell(), v).end_cell();
}

(slice, ((int, int))) $JettonPool$_load(slice sc_0) inline {
    var v'balance = sc_0~load_coins();
    var v'isActive = sc_0~load_int(1);
    return (sc_0, (v'balance, v'isActive));
}

tuple $JettonPool$_as_optional((int, int) v) inline {
    var (v'balance, v'isActive) = v;
    return __tact_tuple_create_2(v'balance, v'isActive);
}

tuple $JettonPool$_load_opt(cell cl) inline {
    if (null?(cl)) {
        return null();
    }
    var sc = cl.begin_parse();
    return $JettonPool$_as_optional(sc~$JettonPool$_load());
}

_ $JettonPool$_get_balance((int, int) v) inline {
    var (v'balance, v'isActive) = v;
    return v'balance;
}

_ $JettonPool$_get_isActive((int, int) v) inline {
    var (v'balance, v'isActive) = v;
    return v'isActive;
}

((int, int)) $JettonPool$_not_null(tuple v) inline {
    throw_if(128, null?(v));
    var (int vvv'balance, int vvv'isActive) = __tact_tuple_destroy_2(v);
    return (vvv'balance, vvv'isActive);
}

((int, int)) $JettonPool$_constructor_balance_isActive(int $balance, int $isActive) inline {
    return ($balance, $isActive);
}

;;
;; Type: PendingSell
;; TLB: _ jettonAddress:address sender:address amount:int257 = PendingSell
;;

builder $PendingSell$_store(builder build_0, (slice, slice, int) v) inline {
    var (v'jettonAddress, v'sender, v'amount) = v;
    build_0 = __tact_store_address(build_0, v'jettonAddress);
    build_0 = __tact_store_address(build_0, v'sender);
    build_0 = build_0.store_int(v'amount, 257);
    return build_0;
}

cell $PendingSell$_store_cell((slice, slice, int) v) inline {
    return $PendingSell$_store(begin_cell(), v).end_cell();
}

((slice, slice, int)) $PendingSell$_not_null(tuple v) inline {
    throw_if(128, null?(v));
    var (slice vvv'jettonAddress, slice vvv'sender, int vvv'amount) = __tact_tuple_destroy_3(v);
    return (vvv'jettonAddress, vvv'sender, vvv'amount);
}

cell $PendingSell$_store_opt(tuple v) inline {
    if (null?(v)) {
        return null();
    }
    return $PendingSell$_store_cell($PendingSell$_not_null(v));
}

(slice, ((slice, slice, int))) $PendingSell$_load(slice sc_0) inline {
    var v'jettonAddress = sc_0~__tact_load_address();
    var v'sender = sc_0~__tact_load_address();
    var v'amount = sc_0~load_int(257);
    return (sc_0, (v'jettonAddress, v'sender, v'amount));
}

tuple $PendingSell$_as_optional((slice, slice, int) v) inline {
    var (v'jettonAddress, v'sender, v'amount) = v;
    return __tact_tuple_create_3(v'jettonAddress, v'sender, v'amount);
}

tuple $PendingSell$_load_opt(cell cl) inline {
    if (null?(cl)) {
        return null();
    }
    var sc = cl.begin_parse();
    return $PendingSell$_as_optional(sc~$PendingSell$_load());
}

_ $PendingSell$_get_amount((slice, slice, int) v) inline {
    var (v'jettonAddress, v'sender, v'amount) = v;
    return v'amount;
}

((slice, slice, int)) $PendingSell$_tensor_cast((slice, slice, int) v) asm """
    NOP
""";

;;
;; Type: WalletDataMessage
;; Header: 0xf2d6cb28
;; TLB: wallet_data_message#f2d6cb28 balance:int257 owner:address jetton:address jetton_wallet_code:^cell = WalletDataMessage
;;

(slice, ((int, slice, slice, cell))) $WalletDataMessage$_load(slice sc_0) inline {
    throw_unless(129, sc_0~load_uint(32) == 4074162984);
    var v'balance = sc_0~load_int(257);
    var v'owner = sc_0~__tact_load_address();
    var v'jetton = sc_0~__tact_load_address();
    var v'jetton_wallet_code = sc_0~load_ref();
    return (sc_0, (v'balance, v'owner, v'jetton, v'jetton_wallet_code));
}

;;
;; Type: DeployJetton
;; Header: 0x5e49412b
;; TLB: deploy_jetton#5e49412b owner:address content:^cell max_supply:int257 token_price:int257 initial_mint:int257 pool:address = DeployJetton
;;

(slice, ((slice, cell, int, int, int, slice))) $DeployJetton$_load(slice sc_0) inline_ref {
    throw_unless(129, sc_0~load_uint(32) == 1581859115);
    var v'owner = sc_0~__tact_load_address();
    var v'content = sc_0~load_ref();
    var v'max_supply = sc_0~load_int(257);
    var v'token_price = sc_0~load_int(257);
    slice sc_1 = sc_0~load_ref().begin_parse();
    var v'initial_mint = sc_1~load_int(257);
    var v'pool = sc_1~__tact_load_address();
    return (sc_0, (v'owner, v'content, v'max_supply, v'token_price, v'initial_mint, v'pool));
}

;;
;; Type: JettonCore
;;

builder $JettonCore$init$_store(builder build_0, (slice, cell, int, int, int, slice) v) inline {
    var (v'owner, v'content, v'max_supply, v'token_price, v'initial_mint, v'pool) = v;
    build_0 = __tact_store_address(build_0, v'owner);
    build_0 = build_0.store_ref(v'content);
    build_0 = build_0.store_int(v'max_supply, 257);
    build_0 = build_0.store_int(v'token_price, 257);
    var build_1 = begin_cell();
    build_1 = build_1.store_int(v'initial_mint, 257);
    build_1 = __tact_store_address(build_1, v'pool);
    build_0 = store_ref(build_0, build_1.end_cell());
    return build_0;
}

(cell, cell) $JettonCore$_init_child(cell sys', slice $owner, cell $content, int $max_supply, int $token_price, int $initial_mint, slice $pool) inline_ref {
    slice sc' = sys'.begin_parse();
    cell source = sc'~load_dict();
    cell contracts = new_dict();
    
    ;; Contract Code: JettonCore
    cell mine = __tact_dict_get_code(source, 53177);
    contracts = __tact_dict_set_code(contracts, 53177, mine);
    
    ;; Contract Code: JettonWalletImp
    cell code_31268 = __tact_dict_get_code(source, 31268);
    contracts = __tact_dict_set_code(contracts, 31268, code_31268);
    
    ;; Build cell
    builder b = begin_cell();
    b = b.store_ref(begin_cell().store_dict(contracts).end_cell());
    b = b.store_int(false, 1);
    b = $JettonCore$init$_store(b, ($owner, $content, $max_supply, $token_price, $initial_mint, $pool));
    return (mine, b.end_cell());
}

;;
;; Type: PoolCore
;;

builder $PoolCore$_store(builder build_0, (slice, cell, cell) v) inline {
    var (v'owner, v'pools, v'pendingSells) = v;
    build_0 = __tact_store_address(build_0, v'owner);
    build_0 = build_0.store_dict(v'pools);
    build_0 = build_0.store_dict(v'pendingSells);
    return build_0;
}

(slice, ((slice, cell, cell))) $PoolCore$_load(slice sc_0) inline {
    var v'owner = sc_0~__tact_load_address();
    var v'pools = sc_0~load_dict();
    var v'pendingSells = sc_0~load_dict();
    return (sc_0, (v'owner, v'pools, v'pendingSells));
}

(slice, cell, cell) $PoolCore$_contract_load() impure inline_ref {
    slice $sc = get_data().begin_parse();
    __tact_context_sys = $sc~load_ref();
    int $loaded = $sc~load_int(1);
    if ($loaded) {
        return $sc~$PoolCore$_load();
    } else {
        ;; Allow only workchain deployments
        throw_unless(137, my_address().preload_uint(11) == 1024);
        return $PoolCore$_contract_init();
    }
}

() $PoolCore$_contract_store((slice, cell, cell) v) impure inline {
    builder b = begin_cell();
    b = b.store_ref(__tact_context_sys);
    b = b.store_int(true, 1);
    b = $PoolCore$_store(b, v);
    set_data(b.end_cell());
}